# For people around programmers

Having programmers in your life can be challenging. They're a strange bunch, keeping odd hours, saying jokes you don't understand, speaking what can seem a foreign language … Often not approachable to the uninitiated, they are almost as likely to solve your problem as they are to laugh that you're a "luser" (comically unskilled computer user).

Don't let this external display of stellar egos and terrible people skills scare you away, programmers are a friendly bunch, perhaps the most accepting group of people I've ever met. Most of their faults stem from a male dominated culture with a large portion of highly intelligent people. Elitism, exclusivism and plain old "being a brat" naturally follow.

If there's one thing you need to know about programmers, it's that they like to be terse. Hanging out with computers all day, putting elegance on the highest pedestal and being deep in thought means they generally like to waste as few words as possible to make a point.

Many take this as rudeness.

At the same time, programmers are very accepting of just about anyone. Show a little interest in their craft and programmers will accept you as their own even if you're a purple-skinned lesbian sea monster.

## Living with programmers


### Understanding interruptions

### Tiptoeing around flow


## Working with programmers

The greatest challenge of working with programmers is having two people working closely together on a single project. Probably sitting close by they are the best source of interruption for each other.

Imagine you are one of the two. Getting up to grab some coffee, do you ask the other person if they want some as well? When hitting a snag, do you ask them a question immediately or wait until a good moment? Noticing a magnificently hilarious cat picture, do you tell them? Share it immediately or send an email, or keep it to yourself?

The answer to these questions will define how great you are to work with.

### How interruptions spread 

There is a team of programmers working together in an office. Deep in thought, code effortlessly flowing from their fingertips, one of them suddenly hits a snag. It happens because a related piece of code designed by another programmer is behaving in unexpected ways. 

Unable to resolve the issue themselves they are violently thrown out of flow. Snapped back into reality our programmer looks around the office in dazed confusion. Will somebody notice their plight? Will somebody volunteer a helping _"What's the problem? Can I help?"_, or is everyone too deep in their own mess to notice?

One of two things is going to happen next.

1. Nothing else to work on, no desire for some creative procrastination, the developer musters the courage to ask a question _now_. They walk up to the person they reckon could help and ask them a question. Now both developers are out of flow.

2. The other likely possibility isn't much better. The developer first arses about on the internet for a while, hoping this will jog their brain and produce a bit of inspiration. It doesn't work. They get up for a walk - somewhere deep in the recesses of their mind a small voice is saying they need to stretch their legs. Another developer notices activity out of the corner of their eye and decides it's time for a break. Now both developers are out of flow.

There are infinite variations on these two courses of events, but they all result in the same thing. Two interrupted developers who will take half an hour at least to get back in flow.

But now the interruption is gaining momentum. It will spread person to person until everyone in the office is out of flow. As the group becomes louder and more chaotic so its interruptive potential grows. Each new member also adds another connective point for interrupting somebody else.

Of course there is also a dampening effect so the smaller and more personally connected the team, the likelier it is all of it will be affected by an interruption.

These events are inevitable, what's important is how far they are allowed to spread and whether they are productive in solving the problem that started them. A certain number of productive interruptions is healthy, even necessary, too many can kill everyone's productivity.

### Communication

For most software projects communication is vital. I'd say _all_ software projects, but hanging out with theoretical computer scientists has made me wary of infinity.

Different communication styles fit different parts of the project. While face-to-face meetings might work best to eke requirements out of clients, instant messaging often works best for software teams to avoid interrupting one another.

Having just the right amount of communication so things run smoothly and developers still have enough time to work is an art that takes most people a few years to develop. Some never get there and the internet is full of programmers complaining about cow-orkers and pointy-haired bosses.

Programmers hate meetings and with good reason.

#### Meetings

Meetings are the best example of a culture clash between people on the maker's schedule and those on the manager's schedule. For a manager, the meeting takes an hour and after a quick break they'll be ready for the next item on their agenda. In terms of time the meeting is free, not only that, it's exactly what they are paid to do and likely represents the best use of company assets.

At least a productive meeting does.

For a programmer the story is different. A single poorly timed meeting can kill an afternoon, sometimes even a day. It takes a while to get back to work and the effort might not be worth it, if there aren't going to be a few hours of empty time before day's end or the next meeting. Another half hour is easily killed before the meeting even begins if the developer reaches a natural stopping point and an imminent meeting means there's no sense in continuing with the next task.

Sure, it's important for programmers to pass know-how between one another and they should definitely be kept in the loop about project objectives, but a meeting is almost never the most productive use of a programmer's time. Especially considering a one hour meeting can easily take three hours of a developer's time.

At $50 an hour a one hour meeting between two programmers is worth $300 in time. Keep that in mind the next time you want to call a meeting, especially if a simple email would do.

Even deciding that a meeting is in fact worth everybody's time, there are other issues making meetings less than ideal.

When people can't go to meetings in person due to geographical constraints, we resort to Skype or similar technology - I hear a lot of people still use telephones, even if mostly for one-on-one conversations.

But participation in a dynamic meeting when you aren't really there is difficult at best. 

Your field of view is narrow, sounds escape the mic, crappy internet connections can make your words choppy or keep you a few seconds behind everybody else. What's worse, even modern means of real-time communication can't solve scheduling conflicts.

And yet, it’s important for everybody to know what happened in the meeting. Add the fact that human memory is fallible and you have a situation where even the people who were there will soon forget what went on.

Meeting minutes will solve the problem for everyone to an extent. Those not present will get to know the main takeaways of the meeting and even after a while everyone will still know the decisions that were made. But the minutes don't capture everything that happens in meetings. 

Conversations race ahead of the person taking notes, they diverge in many directions and often run in circles. Even if the minutes were perfect, they would be boring and difficult to follow. Small teams in particular tend to just write down some notes instead of detailed minutes.

#### Asynchronous communication

Communicating primarily through email or issue tracking systems can solve these problems completely. What you lose in throwing away nonverbal cues, you gain in the perfect logging of conversations and decision making processes.

More importantly, a well written email or issue ticket is much better at conveying information than the muddled real-time thought flow we see in verbal communication. People _think_ before writing.

Perhaps this is a cultural thing, but I have rarely seen people take some time to think through what they are about to say. There is an impetus to avoid pauses lest you seem "slow". To think out loud instead of providing complete answers. This is often a good thing, it lets everyone in on your thoughts, avoids any chance to pad out the painful truth with niceties.

Thinking out loud can also cause problems when a stream of half thoughts makes it difficult to pick out a good solution. Conversations become difficult to follow, especially in notes, and having quick loud thinkers mix with those wanting to think before they speak, can easily ensure the latter never get any air time at all.

As engineers usually have a low tolerance for bullshit and half-baked answers the most valuable input will often not be heard. Not only that, listening to other’s half baked ideas will make many an engineer feel like their time is being wasted.

Another thing emails solve well is group yak shaving.

This happens when somebody raises a tangential point that piques everybody's interest. Before you know it an architecture design meeting devolves into discussing an implementation detail of a soon to be discarded feature.

It feels productive, everyone is learning, but it gets in the way of solving the issue at hand.

When this happens while writing an email I will often cut it out after developing my thought and realising it adds nothing to the overall message. That would be 10 minutes of a meeting wasted.

Sometimes I decide I don't even have to send the email anymore. Just thinking through a problem enough to explain to somebody can solve it for me.

Don't underestimate the benefits of reading and rereading a complex bit of technical info until understanding is reached. Talking in person means the other person needs to repeat what they've said multiple times.

This depends of course on the teaching skills of the other person, sometimes they can munge their explanation so everyone understands.

### Morning time
