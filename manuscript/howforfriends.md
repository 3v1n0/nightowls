# For people around programmers

Having programmers in your life can be challenging. They're a strange bunch, keeping odd hours, saying jokes you don't understand, speaking what can seem a foreign language … Often not approachable to the uninitiated, they are almost as likely to solve your problem as they are to laugh that you're a "luser" (comically unskilled computer user).

Don't let this external display of stellar egos and terrible people skills scare you away, programmers are a friendly bunch, perhaps the most accepting group of people I've ever met. Most of their faults stem from a male dominated culture with a large portion of highly intelligent people. Elitism, exclusivism and plain old "being a brat" naturally follow.

If there's one thing you need to know about programmers, it's that they like to be terse. Hanging out with computers all day, putting elegance on the highest pedestal and being deep in thought means they generally like to waste as few words as possible to make a point.

Many take this as rudeness.

At the same time, programmers are very accepting of just about anyone. Show a little interest in their craft and programmers will accept you as their own even if you're a purple-skinned lesbian sea monster.

## Living with programmers


### Understanding interruptions

### Tiptoeing around flow


## Working with programmers

The greatest challenge of working with programmers is having two people working closely together on a single project. Probably sitting close by they are the best source of interruption for each other.

Imagine you are one of the two. Getting up to grab some coffee, do you ask the other person if they want some as well? When hitting a snag, do you ask them a question immediately or wait until a good moment? Noticing a magnificently hilarious cat picture, do you tell them? Share it immediately or send an email, or keep it to yourself?

The answer to these questions will define how great you are to work with.

### How interruptions spread 

There is a team of programmers working together in an office. Deep in thought, code effortlessly flowing from their fingertips, one of them suddenly hits a snag. It happens because a related piece of code designed by another programmer is behaving in unexpected ways. 

Unable to resolve the issue themselves they are violently thrown out of flow. Snapped back into reality our programmer looks around the office in dazed confusion. Will somebody notice their plight? Will somebody volunteer a helping _"What's the problem? Can I help?"_, or is everyone too deep in their own mess to notice?

One of two things is going to happen next.

1. Nothing else to work on, no desire for some creative procrastination, the developer musters the courage to ask a question _now_. They walk up to the person they reckon could help and ask them a question. Now both developers are out of flow.

2. The other likely possibility isn't much better. The developer first arses about on the internet for a while, hoping this will jog their brain and produce a bit of inspiration. It doesn't work. They get up for a walk - somewhere deep in the recesses of their mind a small voice is saying they need to stretch their legs. Another developer notices activity out of the corner of their eye and decides it's time for a break. Now both developers are out of flow.

There are infinite variations on these two courses of events, but they all result in the same thing. Two interrupted developers who will take half an hour at least to get back in flow.

But now the interruption is gaining momentum. It will spread person to person until everyone in the office is out of flow. As the group becomes louder and more chaotic so its interruptive potential grows. Each new member also adds another connective point for interrupting somebody else.

Of course there is also a dampening effect so the smaller and more personally connected the team, the likelier it is all of it will be affected by an interruption.

These events are inevitable, what's important is how far they are allowed to spread and whether they are productive in solving the problem that started them. A certain number of productive interruptions is healthy, even necessary, too many can kill everyone's productivity.

### Communication

For most software projects communication is vital. I'd say _all_ software projects, but hanging out with theoretical computer scientists has made me wary of infinity.

Different communication styles fit different parts of the project. While face-to-face meetings might work best to eke requirements out of clients, instant messaging often works best for software teams to avoid interrupting one another.

Having just the right amount of communication so things run smoothly and developers still have enough time to work is an art that takes most people a few years to develop. Some never get there and the internet is full of programmers complaining about cow-orkers and pointy-haired bosses.

Programmers hate meetings and with good reason.

#### Meetings

Meetings are the best example of a culture clash between people on the maker's schedule and those on the manager's schedule. For a manager, the meeting takes an hour and after a quick break they'll be ready for the next item on their agenda. In terms of time the meeting is free, not only that, it's exactly what they are paid to do and likely represents the best use of company assets.

At least a productive meeting does.

For a programmer the story is different. A single poorly timed meeting can kill an afternoon, sometimes even a day. It takes a while to get back to work and the effort might not be worth it, if there aren't going to be a few hours of empty time before day's end or the next meeting. Another half hour is easily killed before the meeting even begins if the developer reaches a natural stopping point and an imminent meeting means there's no sense in continuing with the next task.

Sure, it's important for programmers to pass know-how between one another and they should definitely be kept in the loop about project objectives, but a meeting is almost never the most productive use of a programmer's time. Especially considering a one hour meeting can easily take three hours of a developer's time.

At $50 an hour a one hour meeting between two programmers is worth $300 in time. Keep that in mind the next time you want to call a meeting, especially if a simple email would do.

Even deciding that a meeting is in fact worth everybody's time, there are other issues making meetings less than ideal.

When people can't go to meetings in person due to geographical constraints, we resort to Skype or similar technology - I hear a lot of people still use telephones, even if mostly for one-on-one conversations.

But participation in a dynamic meeting when you aren't really there is difficult at best. 

Your field of view is narrow, sounds escape the mic, crappy internet connections can make your words choppy or keep you a few seconds behind everybody else. What's worse, even modern means of real-time communication can't solve scheduling conflicts.

And yet, it’s important for everybody to know what happened in the meeting. Add the fact that human memory is fallible and you have a situation where even the people who were there will soon forget what went on.

Meeting minutes will solve the problem for everyone to an extent. Those not present will get to know the main takeaways of the meeting and even after a while everyone will still know the decisions that were made. But the minutes don't capture everything that happens in meetings. 

Conversations race ahead of the person taking notes, they diverge in many directions and often run in circles. Even if the minutes were perfect, they would be boring and difficult to follow. Small teams in particular tend to just write down some notes instead of detailed minutes.

#### Asynchronous communication

Communicating primarily through email or issue tracking systems can solve these problems completely. What you lose in throwing away nonverbal cues, you gain in the perfect logging of conversations and decision making processes.

More importantly, a well written email or issue ticket is much better at conveying information than the muddled real-time thought flow we see in verbal communication. People _think_ before writing.

Perhaps this is a cultural thing, but I have rarely seen people take some time to think through what they are about to say. There is an impetus to avoid pauses lest you seem "slow". To think out loud instead of providing complete answers. This is often a good thing, it lets everyone in on your thoughts, avoids any chance to pad out the painful truth with niceties.

Thinking out loud can also cause problems when a stream of half thoughts makes it difficult to pick out a good solution. Conversations become difficult to follow, especially in notes, and having quick loud thinkers mix with those wanting to think before they speak, can easily ensure the latter never get any air time at all.

As engineers usually have a low tolerance for bullshit and half-baked answers the most valuable input will often not be heard. Not only that, listening to other’s half baked ideas will make many an engineer feel like their time is being wasted.

Another thing emails solve well is group yak shaving.

This happens when somebody raises a tangential point that piques everybody's interest. Before you know it an architecture design meeting devolves into discussing an implementation detail of a soon to be discarded feature.

It feels productive, everyone is learning, but it gets in the way of solving the issue at hand.

When this happens while writing an email I will often cut it out after developing my thought and realising it adds nothing to the overall message. That would be 10 minutes of a meeting wasted.

Sometimes I decide I don't even have to send the email anymore. Just thinking through a problem enough to explain to somebody can solve it for me.

Also, don't underestimate the benefits of reading and rereading a complex bit of technical info until understanding is reached. Talking in person means the other person needs to repeat what they've said multiple times.

This depends of course on the teaching skills of the other person, sometimes they can munge their explanation so everyone understands.

### Taking advantage of interruptions

No matter how much you try to avoid it, sometimes a combination of email, instant messaging and issue tracking systems just will not do. You have to speak to somebody in person.

However, the general motto still stands, unless people are dying - and they rarely are - you should respect a person's time. Being interrupted while working can create a big mess, so just don't. You wouldn't want somebody interrupting you in the middle of, say, a phone call, would you?

So what are you to do?

Take advantage of naturally occurring interruptions. They also happen to be the easiest to deal with in terms of keeping mental context intact.

Let's say you work in a team that does daily standup meetings to keep tabs on who is doing what and whether anyone has hit a problem and needs some help. This is a ten minute meeting that you can schedule, making it into a half hour distraction or more.

A better approach is to avoid scheduling anything shorter than half an hour at all. When the last person on the team comes into the office they will interrupt everyone by greeting them. Since it's a positive interruption and such a minor one at that nobody will mind. Many won't even break stride in their work!

Now is a great time to have that quick ten minute meeting.

"Daily standup" is a horrible buzz word anyway. It used to be called "Having a cup of coffee with my coworkers every morning". You wouldn't do bad to keep that in mind and treat it as such.

### Batch processing

Another good habit to build when working with programmers and other creatives is batch processing. When you have something to ask, an idea to clear, or anything really, don't giddily rush off and interrupt somebody.

Collect your questions and ideas. Write them down on a post-it note, in a notebook or in an email. When you feel there's enough, wait for a good moment and ask the person for an extended moment of their time.

Programming is fraught with natural stopping points.

When you finish a function. When you write some tests. When you run a full test suite. When you press compile. When you finish a feature. When you pinpoint the code where a bug is hiding. Where you …

This is programming's curse. This is why programmers often get sucked into the vortex of online discussion wasting more time than they would like. But it's also a blessing because it gives their colleagues many opportunities to interrupt without actually interrupting.

When a programmer has reached a natural stopping point int heir work they are naturally inclined to take a little break. Not only do they need to think for a bit before moving on to the next granular task on their list, but the feeling of having just finished something, no matter how small, makes a person want to sit back and bask in the glory.

Now is the time to step in and go through the batch of problems you need help with. It's also very likely that any email you may have sent will be answered at such an occasion.

The problem, then, is spotting a programmer who is between steps.

The simplest way is to leave the decision up to them, send an email, wait for them to answer when the time is right. However, this is fraught with worry whether they noticed the email, how diligent they are with responding to everyone and a bunch of other little problems that mostly have to do with trust.

By the way, do try to clean out your inbox at least once a day. As a courtesy to everyone who respects your time enough to avoid bothering you directly.

Another great approach is to look for signs of procrastination and general time wasting. Is the focus on a twitter client? Are they looking at a browser and it isn't documentation? Playing office warfare or spinning in their chair? Perhaps just getting up and getting a cup of tea?

That's your cue. Pounce.

One thing to keep in mind is fitting everything inside this natural stopping point zone. I find anything that will take longer than five minutes needs to be scheduled off into the far distance. Usually at the end of the work day or in that half hour after lunch when I'm putting off getting back to work.

Don't try to fit anything "hard" in those five minutes either. Where hard is defined as anything that requires thinking deeply about something other than whatever the programmer was doing before. Simple things are okay, helping you with a bug is not.